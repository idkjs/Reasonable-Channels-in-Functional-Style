// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function create(param) {
  return /* record */[
          /* inputs */Queue.create(/* () */0),
          /* messages */Queue.create(/* () */0)
        ];
}

function communicate(channel, message, receiver, is_replicated) {
  process.nextTick((function (param) {
          var receiver$1 = receiver;
          var message$1 = message;
          try {
            return Curry._1(receiver$1, message$1);
          }
          catch (raw_e){
            var e = Caml_js_exceptions.internalToOCamlException(raw_e);
            if (e[0] === Js_exn.$$Error) {
              console.log("JS Error: " + (String(e[1]) + ""));
              return /* () */0;
            } else {
              console.log("Error: " + (String(e) + ""));
              return /* () */0;
            }
          }
        }));
  if (is_replicated) {
    process.nextTick((function (param) {
            recv$prime(channel, receiver, is_replicated);
            return /* () */0;
          }));
    return /* () */0;
  } else {
    return 0;
  }
}

function recv$prime(channel, receiver, is_replicated) {
  var messages = channel[/* messages */1];
  if (Queue.length(messages) > 0) {
    var msg = Queue.take(messages);
    communicate(channel, msg, receiver, is_replicated);
  } else {
    var input = /* tuple */[
      is_replicated,
      receiver
    ];
    Queue.push(input, channel[/* inputs */0]);
  }
  return channel;
}

function send(channel, msg) {
  var inputs = channel[/* inputs */0];
  if (Queue.length(inputs) > 0) {
    var match = Queue.take(inputs);
    communicate(channel, msg, match[1], match[0]);
  } else {
    Queue.push(msg, channel[/* messages */1]);
  }
  return channel;
}

function recv(channel, receiver) {
  return recv$prime(channel, receiver, false);
}

function listen(channel, receiver) {
  recv$prime(channel, receiver, true);
  return /* () */0;
}

function recv_sync(channel) {
  var messages = channel[/* messages */1];
  var match = Queue.length(messages) > 0;
  if (match) {
    return Caml_option.some(Queue.take(messages));
  }
  
}

function to_read_only(channel) {
  return channel;
}

function to_write_only(channel) {
  return channel;
}

exports.create = create;
exports.send = send;
exports.recv = recv;
exports.listen = listen;
exports.recv_sync = recv_sync;
exports.to_read_only = to_read_only;
exports.to_write_only = to_write_only;
/* No side effect */
