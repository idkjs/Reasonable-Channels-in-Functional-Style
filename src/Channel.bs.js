// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function create(param) {
  return {
          inputs: Queue.create(undefined),
          messages: Queue.create(undefined)
        };
}

function communicate(channel, message, receiver, is_replicated) {
  process.nextTick(function (param) {
        try {
          return Curry._1(receiver, message);
        }
        catch (raw_e){
          var e = Caml_js_exceptions.internalToOCamlException(raw_e);
          if (e.RE_EXN_ID === Js_exn.$$Error) {
            console.log("JS Error: " + e._1);
          } else {
            console.log("Error: " + e);
          }
          return ;
        }
      });
  if (is_replicated) {
    process.nextTick(function (param) {
          recv$prime(channel, receiver, is_replicated);
          
        });
    return ;
  }
  
}

function recv$prime(channel, receiver, is_replicated) {
  var messages = channel.messages;
  if (Queue.length(messages) > 0) {
    var msg = Queue.take(messages);
    communicate(channel, msg, receiver, is_replicated);
  } else {
    var input = [
      is_replicated,
      receiver
    ];
    Queue.push(input, channel.inputs);
  }
  return channel;
}

function send(channel, msg) {
  var inputs = channel.inputs;
  if (Queue.length(inputs) > 0) {
    var match = Queue.take(inputs);
    communicate(channel, msg, match[1], match[0]);
  } else {
    Queue.push(msg, channel.messages);
  }
  return channel;
}

function recv(channel, receiver) {
  return recv$prime(channel, receiver, false);
}

function listen(channel, receiver) {
  recv$prime(channel, receiver, true);
  
}

function recv_sync(channel) {
  var messages = channel.messages;
  if (Queue.length(messages) > 0) {
    return Caml_option.some(Queue.take(messages));
  }
  
}

function to_read_only(channel) {
  return channel;
}

function to_write_only(channel) {
  return channel;
}

exports.create = create;
exports.send = send;
exports.recv = recv;
exports.listen = listen;
exports.recv_sync = recv_sync;
exports.to_read_only = to_read_only;
exports.to_write_only = to_write_only;
/* No side effect */
